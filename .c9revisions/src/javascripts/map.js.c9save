{"ts":1358286370855,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var GAT = GAT || {Models: {}, Views: {}, Collections: {}, Routers: {}};\r\nvar util = util || {};\r\n(function(app, util) {\r\n\t\r\n\tapp.Views.MapView = Backbone.View.extend({\r\n\t\tdefaults: {\r\n\t\t\tlatitude: 39.9522\r\n\t\t\t,longitude: -75.1642\r\n\t\t\t,zoom: 16\r\n\t\t\t,baseMapUrl: \"http://{s}.tile.cloudmade.com/b3151979a2e44ef28badec6ef9313327/22677/256/{z}/{x}/{y}.png\"\r\n\t\t\t,baseMapMaxZoom: 18\r\n\t\t\t,maximumAge: 60000\r\n\t\t\t,desiredAccuracy: 10\r\n\t\t\t,minAccuracy: 900 // Anything above this, don't display the geomarker\r\n\t\t\t,imgGeomarkerUrl: \"./img/blue_dot.png\"\r\n\t\t\t,imgGeomarkerSize: [10, 10]\r\n\t\t\t,geocodeInterval: 250\r\n\t\t}\r\n\t\t\r\n\t\t,className: \"map\"\r\n\t\t\r\n\t\t,initialize: function() {\r\n\t\t\t_.bindAll(this, \"render\", \"onLocationFound\", \"renderGeolocation\", \"onMapMoved\", \"panTo\");\r\n\t\t\tthis.options = !_.isEmpty(this.options) ? _.defaults(this.options, this.defaults) : this.defaults;\r\n\t\t\tthis.map = new L.Map(this.el);\r\n\t\t\tthis.map.locate({\r\n\t\t\t\tmaximumAge: this.options.maximumAge\r\n\t\t\t\t,enableHighAccuracy: true\r\n\t\t\t\t,watch: true\r\n\t\t\t});\r\n\t\t\tthis.map.on(\"locationfound\", this.onLocationFound);\r\n\t\t\tthis.map.on(\"moveend\", this.onMapMoved);\r\n\t\t\tthis.geolocation = {};\r\n\t\t\tthis.lastGeocode = {};\r\n\t\t}\r\n\t\t\r\n\t\t,render: function() {\r\n\t\t\tif(this.baseMap === undefined) { // Only do this if it hasn't been rendered already\r\n\t\t\t\t// If we have a GPS location, use that; otherwise, use the default latlng\r\n\t\t\t\tvar latlng = this.geolocation.latlng !== undefined ? this.geolocation.latlng : [this.options.latitude, this.options.longitude];\r\n\t\t\t\tthis.map.setView(latlng, this.options.zoom);\r\n\t\t\t\tthis.baseMap = L.tileLayer(this.options.baseMapUrl, {maxZoom: this.options.baseMapMaxZoom});\r\n\t\t\t\tthis.baseMap.addTo(this.map);\r\n\t\t\t\tthis.renderGeolocation();\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\t\r\n\t\t// Store the latest GPS location, check if we should stop watching the GPS, and trigger events\r\n\t\t,onLocationFound: function(e) {\r\n\t\t\tthis.geolocation.latlng = e.latlng;\r\n\t\t\tthis.geolocation.accuracy = e.accuracy;\r\n\t\t\tthis.trigger(\"locationfound\", this.geolocation); // Trigger on the view so other Backbone objects can bind to the event\r\n\t\t\tif(DEBUG) console.log(\"locationfound\");\r\n\t\t\t\r\n\t\t\t// If the map has already been rendered, render the geolocation\r\n\t\t\tif(this.baseMap !== undefined) this.renderGeolocation();\r\n\t\t\t\r\n\t\t\t// If this location meets our desired accuracy, stop trying to get a better location\r\n\t\t\tif(this.geolocation.accuracy <= this.options.desiredAccuracy) {\r\n\t\t\t\tthis.map.stopLocate();\r\n\t\t\t\tthis.trigger(\"desiredaccuracyfound\", this.geolocation);\r\n\t\t\t\tif(DEBUG) console.log(\"desiredaccuracyfound\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Render dot with circle, denoting user's gps location\r\n\t\t,renderGeolocation: function() {\r\n\t\t\tif(this.geolocation.latlng !== undefined && this.geolocation.accuracy !== undefined) {\r\n\t\t\t\tvar radius = this.geolocation.accuracy / 2;\r\n\t\t\t\tif(radius <= this.options.minAccuracy) {\r\n\t\t\t\t\t// Move marker if it exists, otherwise create it\r\n\t\t\t\t\tif(this.geolocation.marker) {\r\n\t\t\t\t\t\tthis.geolocation.marker.setLatLng(this.geolocation.latlng);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar icon = L.icon({iconUrl: this.options.imgGeomarkerUrl, iconSize: this.options.imgGeomarkerSize});\r\n\t\t\t\t\t\tthis.geolocation.marker = L.marker(this.geolocation.latlng, {icon: icon, clickable: false}).addTo(this.map);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Move/resize circle if it exists, otherwise create it\r\n\t\t\t\t\tif(this.geolocation.circle) {\r\n\t\t\t\t\t\tthis.geolocation.circle.setLatLng(this.geolocation.latlng).setRadius(radius);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar circleOptions = {\r\n\t\t\t\t\t\t\tfillOpacity: 0.1\r\n\t\t\t\t\t\t\t,opacity: 0.2\r\n\t\t\t\t\t\t\t,weight: 3\r\n\t\t\t\t\t\t\t,clickable: false\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tthis.geolocation.circle = L.circle(this.geolocation.latlng, radius, circleOptions).addTo(this.map);\r\n\t\t\t\t\t}\r\n\t\t\t\t} // TODO: else if marker/circle already exists, delete them\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t,onMapMoved: function() {\r\n\t\t\tthis.trigger(\"mapmoved\", this.map.getCenter());\r\n\t\t}\r\n\t\t\r\n\t\t,panTo: function(coords) {\r\n\t\t\tthis.map.panTo(coords);\r\n\t\t}\r\n\t});\r\n\t\r\n\tapp.Models.Geocoder = Backbone.Model.extend({\r\n\t\tdefaults: {\r\n\t\t\tcityState: \"Philadelphia, PA\"\r\n\t\t}\r\n\t\t,initialize: function() {\r\n\t\t\t_.bindAll(this, \"reverseGeocode\", \"geocode\");\r\n\t\t\tthis.utility = new google.maps.Geocoder(); // Call it utility because calling it geocoder is just too confusing with the name of this object\r\n\t\t}\r\n\t\t,reverseGeocode: function(coords) {\r\n\t\t\tthis.set({address: null, coords: coords});\r\n\t\t\tthis.fetch({coords: coords});\r\n\t\t}\r\n\t\t,geocode: function(address) {\r\n\t\t\tthis.set(\"coords\", {});\r\n\t\t\tthis.fetch({address: address});\r\n\t\t}\r\n\t\t,sync: function(method, model, options) {\r\n\t\t\tif(method === \"read\" && (options.coords !== undefined || options.address !== undefined)) {\r\n\t\t\t\tvar params, getCoords;\r\n\t\t\t\tif(options.coords !== undefined) {\r\n\t\t\t\t\tparams = {latLng: new google.maps.LatLng(options.coords.lat, options.coords.lng)};\r\n\t\t\t\t} else if(options.address !== undefined) {\r\n\t\t\t\t\tparams = {address: options.address + \", \" + this.get(\"cityState\")};\r\n\t\t\t\t\tgetCoords = true;\r\n\t\t\t\t}\r\n\t\t\t\tthis.trigger(\"loading:start\");\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tthis.utility.geocode(params, function(results, status) {\r\n\t\t\t\t\tself.trigger(\"loading:end\");\r\n\t\t\t\t\toptions.success({\r\n\t\t\t\t\t\tresults: results\r\n\t\t\t\t\t\t,status: status\r\n\t\t\t\t\t\t,getCoords: getCoords\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t,parse: function(response) {\r\n\t\t\tvar data= {};\r\n\t\t\tif(response.status === \"OK\" && response.results.length) {\r\n\t\t\t\tvar result = this.getGeocodeType(response.results, \"street_address\");\r\n\t\t\t\tif(result) {\r\n\t\t\t\t\tvar addressParts = [];\r\n\t\t\t\t\taddressParts.push(result.address_components[0].long_name);\r\n\t\t\t\t\taddressParts.push(result.address_components[1].long_name);\r\n\t\t\t\t\tdata.address = addressParts.join(\" \");\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If we want to get the coords out of the data (for a geocode, not reverse)\r\n\t\t\t\t\tif(response.getCoords) {\r\n\t\t\t\t\t\tdata.coords = {}; // This will be returned to change the model's coords, for rendering in the form\r\n\t\t\t\t\t\tdata.coords.lat = result.geometry.location.lat();\r\n\t\t\t\t\t\tdata.coords.lng = result.geometry.location.lng();\r\n\t\t\t\t\t\tthis.trigger(\"coordschanged\", data.coords); // Trigger so the map can detect and move\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t}\r\n\t\t,getGeocodeType: function(results, type) {\r\n\t\t\tvar i, ii;\r\n\t\t\tfor(i in results) {\r\n\t\t\t\tfor(ii in results[i].types) {\r\n\t\t\t\t\tif(results[i].types[ii] === type) {\r\n\t\t\t\t\t\treturn results[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n})(GAT, util);"]],"start1":0,"start2":0,"length1":0,"length2":6391}]],"length":6391}
{"contributors":[],"silentsave":false,"ts":1358286381830,"patch":[[{"diffs":[[0,"til) {\r\n"],[-1,"\t"],[1,"    "],[0,"\r\n\tapp.V"]],"start1":113,"start2":113,"length1":17,"length2":20}]],"length":6394,"saved":false}
