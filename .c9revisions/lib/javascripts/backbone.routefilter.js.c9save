{"ts":1359558101925,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1359558103506,"patch":[[{"diffs":[[1,"/*! backbone.routefilter - v0.1.0 - 2013-01-25\r\n* https://github.com/boazsender/backbone.routefilter\r\n* Copyright (c) 2013 Boaz Sender; Licensed MIT */\r\n\r\n/*! backbone.routefilter - v0.1.0 - 2012-08-29\r\n* https://github.com/boazsender/backbone.routefilter\r\n* Copyright (c) 2012 Boaz Sender; Licensed MIT */\r\n/*global Backbone:false, _: false, console: false*/\r\n\r\n(function(Backbone, _) {\r\n\r\n  // Save a reference to the original route method to be called\r\n  // after we pave it over.\r\n  var originalRoute = Backbone.Router.prototype.route;\r\n\r\n  // Create a reusable no operation func for the case where a before\r\n  // or after filter is not set. Backbone or Underscore should have\r\n  // a global one of these in my opinion.\r\n  var nop = function(){};\r\n\r\n  // Extend the router prototype with a default before function,\r\n  // a default after function, and a pave over of _bindRoutes.\r\n  _.extend(Backbone.Router.prototype, {\r\n\r\n    // Add default before filter.\r\n    before: nop,\r\n\r\n    // Add default after filter.\r\n    after: nop,\r\n\r\n    // Pave over Backbone.Router.prototype.route, the public method used\r\n    // for adding routes to a router instance on the fly, and the\r\n    // method which backbone uses internally for binding routes to handlers\r\n    // on the Backbone.history singleton once it's instantiated.\r\n    route: function(route, name, callback) {\r\n\r\n      // If there is no callback present for this route, then set it to\r\n      // be the name that was set in the routes property of the constructor,\r\n      // or the name arguement of the route method invocation. This is what\r\n      // Backbone.Router.route already does. We need to do it again,\r\n      // because we are about to wrap the callback in a function that calls\r\n      // the before and after filters as well as the original callback that\r\n      // was passed in.\r\n      if( !callback ){\r\n        callback = this[ name ];\r\n      }\r\n\r\n      // Create a new callback to replace the original callback that calls\r\n      // the before and after filters as well as the original callback\r\n      // internally.\r\n      var wrappedCallback = _.bind( function() {\r\n\r\n        // Call the before filter and if it returns false, run the\r\n        // route's original callback, and after filter. This allows\r\n        // the user to return false from within the before filter\r\n        // to prevent the original route callback and after\r\n        // filter from running.\r\n        var callbackArgs = new Array(arguments[0],route);\r\n        if ( this.before.apply(this, callbackArgs) === false) {\r\n          return;\r\n        }\r\n\r\n        // If the callback exists, then call it. This means that the before\r\n        // and after filters will be called whether or not an actual\r\n        // callback function is supplied to handle a given route.\r\n        if( callback ) {\r\n          callback.apply( this, callbackArgs );\r\n        }\r\n\r\n        // Call the after filter.\r\n        this.after.apply( this, callbackArgs );\r\n\r\n      }, this);\r\n\r\n      // Call our original route, replacing the callback that was originally\r\n      // passed in when Backboun.Router.route was invoked with our wrapped\r\n      // callback that calls the before and after callbacks as well as the\r\n      // original callback.\r\n      return originalRoute.call( this, route, name, wrappedCallback );\r\n    }\r\n\r\n  });\r\n\r\n}(Backbone, _));"]],"start1":0,"start2":0,"length1":0,"length2":3361}]],"length":3361,"saved":false}
